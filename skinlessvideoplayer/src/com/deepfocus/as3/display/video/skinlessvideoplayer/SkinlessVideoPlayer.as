package com.deepfocus.as3.display.video.skinlessvideoplayer{	import com.deepfocus.as3.display.video.skinlessvideoplayer.events.VideoControllerEvent;	import com.deepfocus.as3.display.video.skinlessvideoplayer.model.VideoPlayerBrain;		import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.StageDisplayState;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.external.ExternalInterface;	import flash.media.Video;		import mx.events.ResizeEvent;	public class SkinlessVideoPlayer extends Sprite	{		protected var _videoPlayerBrain		:VideoPlayerBrain;		protected var _video				:Video;		protected var _videoPath			:String;		protected var _volume				:Number;		protected var _spinner				:MovieClip;		protected var _mouseInteracter		:Sprite;				public static const PLAYER_STATE_INIT				:String = "player_state_init";		public static const PLAYER_STATE_PAUSE				:String = "player_state_pause";		public static const PLAYER_STATE_RESUME				:String = "player_state_resume";		public static const PLAYER_STATE_SCRUB_START		:String = "player_state_scrub_start";		public static const PLAYER_STATE_SCRUB_END			:String = "player_state_scrub_end";		public static const PLAYER_STATE_END				:String = "player_state_end";		protected var _currentState:String;		protected var _beforeScrubState:String;		public function SkinlessVideoPlayer($videoPath:String, $width:Number, $height:Number)		{			_videoPath						= $videoPath;			_video							= new Video($width, $height);			addEventListener(Event.ADDED_TO_STAGE, _init, false, 0, true);		}				private function _init($e:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, _init, false);						ExternalInterface.addCallback('flashPauseHandler', onPauseHandler);			ExternalInterface.addCallback('flashResumeHandler', onResumeHandler);			ExternalInterface.addCallback('flashOnInitScrubHandler', onInitScrubHandler);			ExternalInterface.addCallback('flashOnScrubHandler', onScrubHandler);			ExternalInterface.addCallback('flashOnEndScrubHandler', onEndScrubHandler);			ExternalInterface.addCallback('flashVolumeChangeHandler', onVolumeChangeHandler);						this.addChild(_video);			_videoPlayerBrain = new VideoPlayerBrain(_video, _videoPath, updateScrubber);			_videoPlayerBrain.addEventListener(VideoControllerEvent.VIDEO_OVER, onVideoOverHandler);			_videoPlayerBrain.addEventListener(VideoControllerEvent.CONNECTION_MADE, onConnectionMade);			_videoPlayerBrain.addEventListener(VideoControllerEvent.INVALID_TIME, onInvalidTime);						stage.addEventListener(MouseEvent.CLICK, onFullScreenHandler, false, 0, true);							currentState = PLAYER_STATE_INIT;		}				//--------------------------------------------------------------------------		//  PUBLIC METHODS		//--------------------------------------------------------------------------		public function get currentState():String { return _currentState; }		public function set currentState(value:String):void {			_currentState = value;  			playerStateUpdate();		}				protected function playerStateUpdate():void		{			switch (_currentState)			{				case PLAYER_STATE_INIT:					_videoPlayerBrain.openConnection();					_videoPlayerBrain.soundTransform(1);					_videoPlayerBrain.indicateNetStream = true;					break;				case PLAYER_STATE_RESUME:					_videoPlayerBrain.resume();					break;				case PLAYER_STATE_PAUSE:					_videoPlayerBrain.pause();					break;				case PLAYER_STATE_END:					_videoPlayerBrain.seek(0);					_videoPlayerBrain.pause();					_videoPlayerBrain.indicateNetStream = false;					break;			}		}				//--------------------------------------------------------------------------		//  EXTERNAL INTERFACE CALLBACKS		//--------------------------------------------------------------------------		protected function onPauseHandler():void		{			currentState = PLAYER_STATE_PAUSE;		}		protected function onResumeHandler():void		{			currentState = PLAYER_STATE_RESUME;		}		protected function onInitScrubHandler():void		{			_beforeScrubState = currentState;			currentState = PLAYER_STATE_PAUSE;		}		protected function onScrubHandler($obj:Object):void		{			_videoPlayerBrain.seek($obj.ratio);		}		protected function onEndScrubHandler():void		{			if (_beforeScrubState == 'undefined') return;			currentState = _beforeScrubState;			_beforeScrubState = 'undefined';		}		protected function onVolumeChangeHandler($obj):void		{			_videoPlayerBrain.soundTransform($obj.volume);		}						protected function onFullScreenHandler($e:MouseEvent):void		{			switch(stage.displayState) {				case StageDisplayState.NORMAL:					//ExternalInterface.call('console.log', 'normal');					_videoPlayerBrain.sizeByRatio(_video.width, _video.height, stage.stageWidth, stage.stageHeight);					stage.displayState = StageDisplayState.FULL_SCREEN;					break;				case StageDisplayState.FULL_SCREEN:					//ExternalInterface.call('console.log', 'fullscreen');					stage.displayState = StageDisplayState.NORMAL;					break;			}		}		//--------------------------------------------------------------------------		//  VIDEO BRAIN CALLBACKS		//--------------------------------------------------------------------------		protected function onVideoOverHandler($e:VideoControllerEvent):void		{			currentState = PLAYER_STATE_END;			ExternalInterface.call('videoOver');		}				protected function onInvalidTime($e:VideoControllerEvent):void		{			currentState = PLAYER_STATE_END;			dispatchEvent($e);		}				private function onConnectionMade($e:VideoControllerEvent):void		{			_videoPlayerBrain.removeEventListener(VideoControllerEvent.CONNECTION_MADE, onConnectionMade);			currentState = PLAYER_STATE_END;		}				private function updateScrubber($obj:Object):void {			ExternalInterface.call('update', $obj);		}					}}